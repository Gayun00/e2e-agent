# Playwright E2E Agent 설계 과정

## 프로젝트 개요

Playwright E2E 테스트를 자동으로 생성하는 AI Agent 개발 프로젝트입니다. Page Object Model(POM) 패턴을 따르며, 사용자가 제공한 시나리오와 도메인 지식을 기반으로 테스트 코드를 생성합니다.

## 설계 과정

### 1단계: 초기 아이디어 및 요구사항 정의

**초기 아이디어:**
- POM 패턴 기반 테스트 자동 생성
- 시나리오 분석 → 페이지 객체 생성 → 요소 선택자 결정 → 테스트 코드 생성
- LLM이 요소 선택자를 추측하고 개발자 확인 받기

**핵심 워크플로우:**
1. 시나리오에 필요한 페이지 객체 생성 (POM)
2. 상호작용할 요소 선택 방식 결정
3. 페이지별 동작 프로퍼티 생성
4. 시나리오별 테스트 작성
5. E2E 테스트 문서 작성 및 업데이트

### 2단계: 요구사항 구체화

**주요 결정 사항:**

#### 2.1 도메인 지식 문서의 필요성
**문제:** Agent가 테스트를 작성하려면 애플리케이션에 대한 컨텍스트가 필요
**해결:** 도메인 지식 문서 도입
- 페이지 정보 (경로, 설명, 접근 방법)
- 테스트 플로우
- 도메인 특화 정보 (인증, 데이터, 로딩 등)

**참고 시점:** 페이지 객체 생성 전에 먼저 참고하여 정확도 향상

#### 2.2 페이지 경로 확인 프로세스
**문제:** LLM이 추론한 경로가 정확하지 않을 수 있음
**해결:** 단계별 확인 프로세스
1. 도메인 문서에서 경로 확인
2. 없으면 LLM이 추론
3. 사용자에게 확인 요청
4. 확정된 경로로 `goto()` 메서드 및 검증 메서드 생성

#### 2.3 요소 선택자 검증 프로세스
**문제:** 선택자가 실제로 작동하는지 확인 필요
**해결:** 브라우저 기반 검증
1. 브라우저 실행
2. 여러 선택자 전략 분석 (role, placeholder, test-id 등)
3. 실제 페이지에서 검증
4. 사용자에게 확인 및 수정 요청

#### 2.4 CLI 인터페이스
**문제:** 사용자가 쉽게 접근하고 자동화 파이프라인에 통합 필요
**해결:** CLI 도구 제공
- 대화형 모드
- 설정 파일 지원
- 사용자 지정 디렉토리 또는 Playwright 기본 구조 사용

### 3단계: 기술 스택 선정

#### 3.1 브라우저 자동화: MCP 통합 결정

**초기 계획:** Playwright를 직접 사용하여 브라우저 제어
**문제점:** 브라우저 제어 로직을 처음부터 구현해야 함

**개선안:** Microsoft Playwright MCP 서버 활용
**이유:**
- 이미 검증된 도구들 제공
- 브라우저 제어 로직 구현 불필요
- 선택자 검증, 스크린샷, 요소 상호작용 등 기능 즉시 사용 가능

**MCP 도구 활용:**
- `playwright_navigate`: 페이지 이동 및 경로 검증
- `playwright_click/fill`: 선택자 검증
- `playwright_screenshot`: 시각적 피드백
- `playwright_evaluate`: 페이지 구조 분석
- `playwright_get_text/get_attribute`: 요소 정보 확인

**아키텍처 변경:**
```
Agent → MCP Client → Playwright MCP Server → Browser
```

#### 3.2 LLM 선택: Claude vs GPT-4

**고려 사항:**
1. 여러 LLM 지원 가능성
2. Prompt Caching 필요성
3. 코드 생성 품질
4. 비용 효율성

**Prompt Caching의 중요성:**
- 시스템 프롬프트 (2,000 토큰)
- 도메인 지식 (3,000 토큰)
- 기존 페이지 객체 (5,000 토큰)
- **총 10,000 토큰이 매 호출마다 반복**

**비용 비교:**
- 캐싱 없이: 10,000 토큰 × 20회 = 200,000 토큰
- 캐싱 사용: 10,000 + (1,000 × 19회) = 29,000 토큰 (85% 절감)

**SDK 선택 논의:**

**옵션 1: Vercel AI SDK**
- ✅ 여러 LLM 지원 (Claude, GPT-4, Gemini)
- ✅ Langfuse 통합
- ✅ 구조화된 출력
- ❌ Anthropic Prompt Caching 미지원

**옵션 2: Anthropic SDK**
- ✅ Prompt Caching 지원
- ✅ Claude에 최적화
- ✅ 긴 컨텍스트 (200K)
- ❌ 초기에는 Claude만 지원

**최종 결정: Anthropic SDK + Claude 3.5 Sonnet**

**이유:**
1. **코드 생성 품질**: TypeScript/Playwright 코드 생성 우수
2. **긴 컨텍스트**: 200K 토큰 - 모든 컨텍스트 포함 가능
3. **Prompt Caching**: 비용 90% 절감
4. **구조화된 추론**: 단계별 분석 및 코드 생성 탁월
5. **비용 효율성**: GPT-4 대비 저렴

**향후 확장:** 추상화 레이어를 통해 다른 LLM 지원 가능

#### 3.3 모니터링: Langfuse

**선택 이유:**
- LLM 호출 추적 및 분석
- 비용 모니터링
- 성능 최적화
- 디버깅 지원

### 4단계: 아키텍처 설계

#### 레이어 구조

```
┌─────────────────────────────────────────────────────────────┐
│                         CLI Layer                            │
│              (사용자 인터페이스 및 입력 처리)                │
└───────────────────────────┬─────────────────────────────────┘
                            │
┌─────────────────────────────────────────────────────────────┐
│                    Orchestration Layer                       │
│                  (워크플로우 관리 및 조율)                   │
└───────────────────────────┬─────────────────────────────────┘
                            │
┌─────────────────────────────────────────────────────────────┐
│                      Service Layer                           │
│     (도메인 문서, 페이지 객체, 선택자, 테스트 구성)         │
└───────────────────────────┬─────────────────────────────────┘
                            │
┌─────────────────────────────────────────────────────────────┐
│                        LLM Layer                             │
│              (Anthropic API + Prompt Caching)                │
└───────────────────────────┬─────────────────────────────────┘
                            │
┌─────────────────────────────────────────────────────────────┐
│                   Infrastructure Layer                       │
│            (Langfuse, MCP Client, File System)               │
└─────────────────────────────────────────────────────────────┘
```

#### 핵심 컴포넌트

1. **Agent Orchestrator**: 워크플로우 관리
2. **Domain Document Manager**: 도메인 지식 관리
3. **Page Object Generator**: 페이지 객체 생성
4. **MCP Client Service**: Playwright MCP 서버 통신
5. **Selector Determiner**: 선택자 결정 및 검증
6. **Test Scenario Composer**: 테스트 시나리오 구성
7. **LLM Service Layer**: Claude API 호출 및 캐싱

### 5단계: 워크플로우 정의

```
1. 도메인 지식 로드
   ↓
2. 테스트 시나리오 분석
   ↓
3. 페이지 객체 생성
   - 페이지 식별
   - 경로 추론 및 확인
   - goto() 및 검증 메서드 생성
   ↓
4. 요소 선택자 결정
   - MCP로 브라우저 실행
   - 선택자 후보 생성
   - 실제 페이지에서 검증
   - 사용자 확인
   ↓
5. 테스트 동작 생성
   - 페이지별 액션 메서드
   - 적절한 대기 및 검증 포함
   ↓
6. 테스트 시나리오 구성
   - describe/test 블록 생성
   - setup/teardown 추가
   ↓
7. 문서 업데이트
   - 도메인 지식 문서 갱신
```

## 주요 설계 결정 요약

| 항목 | 결정 | 이유 |
|------|------|------|
| 브라우저 자동화 | MCP 통합 | 검증된 도구 활용, 개발 범위 축소 |
| LLM | Claude 3.5 Sonnet | 코드 생성 품질, Prompt Caching, 비용 효율 |
| SDK | Anthropic SDK | Prompt Caching 지원 필수 |
| 모니터링 | Langfuse | LLM 호출 추적 및 비용 관리 |
| 인터페이스 | CLI | 자동화 파이프라인 통합 용이 |
| 패턴 | POM | 유지보수성 및 재사용성 |
| 도메인 지식 | 별도 문서 | 컨텍스트 제공 및 정확도 향상 |

## 기술 스택

### 핵심 라이브러리
- **TypeScript**: 타입 안전성
- **Node.js**: 런타임
- **Anthropic SDK**: Claude API
- **Langfuse**: LLM 추적
- **MCP SDK**: MCP 클라이언트
- **Playwright MCP Server**: 브라우저 자동화
- **Commander.js**: CLI
- **Inquirer.js**: 대화형 프롬프트
- **Zod**: 스키마 검증

## 예상 사용 흐름

```bash
# 1. 초기 설정
e2e-agent init

# 2. 도메인 지식 문서 작성 (선택)
# docs/e2e-domain-knowledge.md

# 3. 테스트 생성
e2e-agent generate --scenario "로그인 테스트"

# Agent 실행:
# - 도메인 문서 로드
# - 시나리오 분석
# - 페이지 식별: LoginPage, MainPage
# - 경로 확인: /login, /
# - 브라우저 실행 (MCP)
# - 선택자 검증 및 사용자 확인
# - 페이지 객체 생성: tests/pages/LoginPage.ts
# - 테스트 파일 생성: tests/login.spec.ts
```

## 향후 개선 방향

1. **멀티 LLM 지원**: 추상화 레이어로 GPT-4, Gemini 지원
2. **멀티 브라우저**: Firefox, WebKit 지원
3. **병렬 처리**: 여러 시나리오 동시 생성
4. **테스트 리팩토링**: 기존 테스트 개선 제안
5. **시각적 회귀 테스트**: 스크린샷 비교
6. **CI/CD 통합**: GitHub Actions 템플릿
7. **웹 UI**: 브라우저 기반 인터페이스

## 결론

이 프로젝트는 AI와 브라우저 자동화를 결합하여 E2E 테스트 작성의 생산성을 크게 향상시킵니다. MCP 통합으로 개발 범위를 줄이고, Claude의 Prompt Caching으로 비용을 절감하며, 단계별 사용자 확인으로 정확도를 보장합니다.

핵심은 **"LLM이 추측하고, 브라우저로 검증하고, 사용자가 확인하는"** 협업 프로세스입니다.
